# 模板方法模式 (Template Method Pattern)

### 1. 禅师说戏 (Story)

**出处**：《设计模式之禅》第10章。

**剧情**：我们要制造**悍马（Hummer）**越野车。
不管你是 H1 型号（军用）还是 H2 型号（民用），车子跑起来的流程是死的：
`启动` -> `引擎响` -> `跑` -> `喇叭响` -> `停车`。

但是，细节不同：
- H1 引擎声是“轰轰轰”，H2 是“吱吱吱”。
- H1 喇叭一直响，H2 可以控制响不响。

**禅意**：**“流程由父类控制，细节由子类实现”**。
父类（模板）定规矩，说：“必须先发动再跑”。子类（实现）填空，说：“我发动的声音是这样的”。这就是**好莱坞原则**：“Don't call us, we'll call you.”（别调我，我会调你）。

### 2. 核心逻辑

- **抽象模板 (Abstract Class)**：定义并实现一个模板方法。这个模板方法一般是一个具体方法，它给出了一个算法的轮廓和骨架。
- **具体实现 (Concrete Class)**：实现抽象类中所定义的抽象方法，完成算法中特定于子类的步骤。
- **钩子方法 (Hook Method)**：在抽象类中定义并实现，但子类可以重写它，用于控制父类算法的流程。

### 3. 实现说明

- **V1 (Basic)**: 劣质实现，展示代码重复和硬编码流程。
- **V2 (Standard)**: 标准模板方法实现，使用抽象类和 `final` 模板方法。
- **V3 (Hook)**: 进阶实现，引入钩子方法实现反向控制，并使用 `ThreadLocal` 解决了单例模式下的线程安全隐患。

### 4. 源码寻宝 (Framework)

- **JDK - `AbstractQueuedSynchronizer` (AQS)**：
  - 并发编程的基石。`acquire()` 是模板方法，它定义了获取锁的死流程（尝试 -> 入队 -> 阻塞）。
  - `tryAcquire()` 是钩子，留给 `ReentrantLock` 等子类去实现。
- **Spring - `AbstractApplicationContext.refresh()`**：
  - 这是 Spring 启动的核心。`refresh()` 是一个巨大的模板方法，定义了 13 个步骤。
  - `postProcessBeanFactory()` 是钩子，留给子类（如 Web 环境）去扩展。

### 5. 内功拷问 (JVM & Concurrency)

- **`final` 关键字**：模板方法必须加 `final`，防止子类篡改算法骨架。
- **线程安全**：在 Spring 等单例环境中，模板类不应持有可变的成员变量。V3 版本演示了如何利用 `ThreadLocal` 优雅地解决由于“钩子状态”导致的线程竞争问题。
