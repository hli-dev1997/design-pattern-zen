# 策略模式 (Strategy Pattern)

> 📖 对应《设计模式之禅》第18章：策略模式

---

## 一、概述

**策略模式**（Strategy Pattern）定义一系列算法，把它们一个个封装起来，并且使它们可互相替换。策略模式使得算法可独立于使用它的客户而变化。

> **核心思想**：诸葛亮给赵云的三个锦囊妙计——到了什么情况，打开什么锦囊

---

## 二、角色定义

| 角色 | 说明 |
|------|------|
| Strategy（策略接口） | 定义所有支持的算法的公共接口 |
| ConcreteStrategy（具体策略） | 实现策略接口，提供具体算法实现 |
| Context（上下文） | 持有一个策略引用，负责与策略对象交互 |

---

## 三、为什么需要策略模式

假设有多种算法需要切换：
- **使用 if-else**：代码臃肿，难以维护，违反开闭原则
- **使用策略模式**：算法独立封装，可随时切换，符合开闭原则

---

## 四、版本演进

- `common` - 公共组件：统一演示入口
- `v1_basic` - 烂代码：赵云的噩梦——硬编码 if-else
- `v2_standard` - 标准策略模式：锦囊妙计的正确打开方式
- `v3_enum` - 枚举策略：Effective Java 推荐的顶级写法

---

## 五、类图

```
           ┌─────────────────┐
           │    Context      │
           ├─────────────────┤
           │ -strategy: IStr │
           │ +operate()      │
           └────────┬────────┘
                    │
                    ▼
           ┌─────────────────┐
           │   IStrategy     │
           │   (interface)   │
           ├─────────────────┤
           │ +operate()      │
           └─────────────────┘
                    △
                    │
    ┌───────────────┼───────────────┐
    │               │               │
┌───┴────┐    ┌─────┴───┐    ┌──────┴────┐
│BackDoor│    │GreenLit │    │BlockEnemy │
├────────┤    ├─────────┤    ├───────────┤
│+operate│    │+operate │    │+operate   │
└────────┘    └─────────┘    └───────────┘
```

---

## 六、经典案例：诸葛亮的锦囊妙计

### 问题场景
- **场景一（刚到吴国）**：找乔国老开后门
- **场景二（乐不思蜀）**：求吴国太开绿灯
- **场景三（被追杀）**：孙夫人断后

### 结构说明
```
Context（锦囊袋子）
├── 持有 IStrategy（锦囊接口）的引用
└── 赵云根据场景选择锦囊

IStrategy（锦囊接口）
├── BackDoor（具体策略一）
├── GivenGreenLight（具体策略二）
└── BlockEnemy（具体策略三）
```

---

## 七、适用场景

1. **多种算法切换**：系统需要在多种算法中选择一个
2. **避免条件判断**：消除大量的 if-else 或 switch-case
3. **算法独立封装**：算法需要独立于客户端变化
4. **同一行为不同实现**：需要在运行时动态切换算法

---

## 八、JDK & Spring 应用

| 框架 | 类 | 说明 |
|------|-----|------|
| JDK | `Comparator` | 比较策略接口 |
| JDK | `java.util.Arrays.sort()` | 可传入不同比较器 |
| JDK | `ThreadPoolExecutor` | 拒绝策略 RejectedExecutionHandler |
| Spring | `Resource` | 资源访问策略 |
| Spring | `InstantiationStrategy` | Bean 实例化策略 |

---

## 九、与其他模式对比

| 模式 | 目的 | 使用时机 |
|------|------|----------|
| 策略模式 | 算法互换 | 行为可切换，单一维度 |
| 状态模式 | 状态切换 | 对象状态改变行为 |
| 命令模式 | 请求封装 | 解耦请求发送者和接收者 |
| 桥接模式 | 抽象与实现分离 | 多维度变化 |

---

## 十、面试常见问题

### Q1：策略模式解决什么问题？

> **答**：消除大量的 if-else 条件判断，将算法封装成独立的类，使其可以互相替换，符合开闭原则。

### Q2：策略模式和状态模式的区别？

> **答**：
> - **策略模式**：客户端知道所有策略，主动选择策略
> - **状态模式**：客户端不关心状态，状态自动切换行为

### Q3：为什么说枚举策略是最佳实践？

> **答**：
> - 枚举天生单例，线程安全
> - 代码简洁，无需 Context 类
> - Effective Java 推荐的写法

---

> 📌 **学习建议**：策略模式的核心是"算法可替换"，实际开发中常与工厂模式配合使用，由工厂根据条件返回具体策略。
