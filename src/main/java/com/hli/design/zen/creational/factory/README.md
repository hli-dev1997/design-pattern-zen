# 工厂模式（Factory Pattern）

> 📖 对应《设计模式之禅》第8章：工厂方法模式、第9章：抽象工厂模式

---

## 一、模式简介

**工厂模式**将对象的创建过程封装起来，由工厂类负责创建对象，客户端无需知道具体创建细节。

> **核心思想**：将 `new` 操作封装，实现创建与使用的分离

---

## 二、核心原理

### 2.1 三种工厂模式演进

```
简单工厂 → 工厂方法 → 抽象工厂
   ↓           ↓           ↓
一个工厂    多个工厂     工厂的工厂
创建所有    各自创建     创建产品族
```

### 2.2 简单工厂（Simple Factory）

```
┌─────────────┐       ┌─────────────┐
│   Client    │──────▶│   Factory   │
└─────────────┘       └──────┬──────┘
                             │ create()
                             ▼
                    ┌────────────────┐
                    │    Product     │
                    └────────────────┘
                      ▲          ▲
             ┌────────┘          └────────┐
      ┌──────┴──────┐          ┌──────┴──────┐
      │  ProductA   │          │  ProductB   │
      └─────────────┘          └─────────────┘
```

**特点**：一个工厂创建所有产品，通过参数区分

---

### 2.3 工厂方法（Factory Method）

```
┌─────────────┐       ┌─────────────┐
│   Client    │──────▶│   Factory   │ (抽象)
└─────────────┘       └──────┬──────┘
                             │
                ┌────────────┴────────────┐
         ┌──────┴──────┐          ┌──────┴──────┐
         │  FactoryA   │          │  FactoryB   │
         └──────┬──────┘          └──────┬──────┘
                │                        │
         ┌──────┴──────┐          ┌──────┴──────┐
         │  ProductA   │          │  ProductB   │
         └─────────────┘          └─────────────┘
```

**特点**：每个产品对应一个工厂，符合开闭原则

---

### 2.4 抽象工厂（Abstract Factory）

```
┌─────────────────────────────────────────┐
│           AbstractFactory               │
├─────────────────────────────────────────┤
│ + createProductA(): ProductA            │
│ + createProductB(): ProductB            │
└─────────────────────────────────────────┘
                    ▲
        ┌───────────┴───────────┐
┌───────┴───────┐       ┌───────┴───────┐
│ ConcreteFactory1 │    │ ConcreteFactory2 │
│ (创建产品族1)     │    │ (创建产品族2)     │
└───────────────┘       └───────────────┘
```

**特点**：创建一系列相关的产品（产品族）

---

## 三、代码实现规划

本目录将包含以下版本：

```
factory/
├── README.md                # 本说明文档
├── common/                  # 公共接口和类
│   ├── Product.java         # 产品接口
│   └── Factory.java         # 工厂接口
├── v1_bad/                  # 反例：无工厂，直接new
│   └── Client.java
├── v2_simple/               # 简单工厂
│   └── SimpleFactory.java
├── v3_method/               # 工厂方法
│   ├── FactoryA.java
│   └── FactoryB.java
└── v4_abstract/             # 抽象工厂
    ├── AbstractFactory.java
    └── ConcreteFactory.java
```

---

## 四、面试高频问题

### Q1：三种工厂模式的区别？

| 模式 | 工厂数量 | 产品数量 | 适用场景 |
|------|----------|----------|----------|
| 简单工厂 | 1个 | 有限的几种 | 产品类型少、不会扩展 |
| 工厂方法 | 多个 | 多种 | 产品类型多、需要扩展 |
| 抽象工厂 | 多个 | 产品族 | 创建一系列相关产品 |

---

### Q2：工厂模式解决什么问题？

> **答**：
> 1. **解耦**：客户端不需要知道具体类名，只需知道工厂
> 2. **扩展**：新增产品只需添加新工厂，符合开闭原则
> 3. **封装**：隐藏创建细节（如复杂初始化、依赖注入）
> 4. **统一管理**：对象创建逻辑集中管理

---

### Q3：简单工厂的缺点是什么？

> 1. 违反开闭原则：新增产品必须修改工厂类
> 2. 工厂类职责过重：所有创建逻辑堆积
> 3. 不利于测试：无法替换具体工厂

**改进方案**：使用工厂方法模式

---

### Q4：工厂方法 vs 抽象工厂？

| 维度 | 工厂方法 | 抽象工厂 |
|------|----------|----------|
| 关注点 | 单个产品的创建 | 产品族的创建 |
| 工厂接口 | 一个创建方法 | 多个创建方法 |
| 扩展方向 | 横向扩展产品种类 | 纵向扩展产品族 |
| 典型场景 | 日志工厂 | 跨平台UI工厂 |

---

### Q5：工厂模式的缺点是什么？

| 缺点 | 说明 |
|------|------|
| 类数量增加 | 每个产品需要一个工厂类 |
| 复杂度增加 | 引入额外的抽象层 |
| 不适合简单场景 | 如果只有1-2种产品，过度设计 |

---

## 五、实际项目应用

### 5.1 JDK 源码

| 类/方法 | 模式 | 说明 |
|---------|------|------|
| `Calendar.getInstance()` | 简单工厂 | 根据时区返回不同实现 |
| `NumberFormat.getInstance()` | 简单工厂 | 根据Locale返回实现 |
| `Collection.iterator()` | 工厂方法 | 每个集合返回自己的迭代器 |
| `DocumentBuilderFactory` | 抽象工厂 | XML解析器工厂 |

### 5.2 Spring 源码

| 类/接口 | 模式 | 说明 |
|---------|------|------|
| `BeanFactory` | 抽象工厂 | Spring 容器核心 |
| `FactoryBean` | 工厂方法 | 自定义 Bean 创建逻辑 |
| `ProxyFactory` | 工厂方法 | 创建 AOP 代理 |

### 5.3 大厂应用场景

| 场景 | 模式 | 说明 |
|------|------|------|
| 数据库连接池 | 工厂方法 | `DataSourceFactory` |
| 日志框架 | 工厂方法 | `LoggerFactory.getLogger()` |
| 支付系统 | 简单工厂 | 根据支付方式创建处理器 |
| 消息队列 | 抽象工厂 | Kafka/RocketMQ 客户端 |
| 存储服务 | 抽象工厂 | OSS/本地/HDFS适配 |

---

## 六、代码实践指导

### 6.1 何时使用工厂模式？

✅ **适合使用**：
- 对象创建逻辑复杂（多步初始化、依赖注入）
- 需要根据条件创建不同类型的对象
- 对象类型可能扩展
- 需要统一管理对象创建

❌ **不适合使用**：
- 对象创建简单，直接 new 即可
- 对象类型固定，不会扩展

### 6.2 选型建议

```
产品类型少且固定？ ──是──▶ 简单工厂
        │
        否
        │
        ▼
产品需要扩展？ ──是──▶ 工厂方法
        │
        否
        │
        ▼
需要创建产品族？ ──是──▶ 抽象工厂
```

### 6.3 结合 Spring 使用

```java
// 方式1：使用 @Bean 方法作为工厂
@Bean
public DataSource dataSource() {
    return createDataSource(config);  // 工厂方法
}

// 方式2：实现 FactoryBean 接口
public class MyFactoryBean implements FactoryBean<MyObject> {
    @Override
    public MyObject getObject() {
        return new MyObject();  // 自定义创建逻辑
    }
}
```

---

## 七、面试深挖追问

1. **FactoryBean 和 BeanFactory 的区别？**
   - `BeanFactory`：Spring 容器的顶层接口，管理所有 Bean
   - `FactoryBean`：特殊的 Bean，用于自定义创建复杂对象

2. **工厂模式和依赖注入的关系？**
   - 依赖注入是工厂模式的升级版
   - 容器充当"超级工厂"，管理所有对象的创建和依赖

3. **如何设计一个可扩展的工厂？**
   - 使用策略注册表（Map）
   - 结合反射或 SPI 机制
   - Spring 环境下使用 `@Qualifier` + 注入 Map

---

## 八、待实现代码清单

- [ ] `Product.java` - 产品接口
- [ ] `SimpleFactory.java` - 简单工厂实现
- [ ] `AbstractFactory.java` - 抽象工厂接口
- [ ] `ConcreteFactory.java` - 具体工厂实现
- [ ] `FactoryMethodTest.java` - 工厂方法测试

---

> 📌 **学习建议**：从简单工厂开始，理解"封装创建"的核心思想，再逐步学习工厂方法和抽象工厂。
