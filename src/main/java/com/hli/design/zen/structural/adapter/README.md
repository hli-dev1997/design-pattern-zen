# 适配器模式 (Adapter Pattern)

> 📖 对应《设计模式之禅》第17章：适配器模式

---

## 一、概述

**适配器模式**（Adapter Pattern）是将一个类的接口转换成客户期望的另一个接口，使原本接口不兼容的类可以一起工作。

> **核心思想**：接口转换，让不兼容的接口协同工作

---

## 二、角色定义

| 角色 | 说明 |
|------|------|
| Target（目标接口） | 客户端期望的接口 |
| Adaptee（被适配者） | 需要被适配的现有类 |
| Adapter（适配器） | 将 Adaptee 转换为 Target 接口 |
| Client（客户端） | 使用 Target 接口的调用方 |

---

## 三、两种实现方式

| 类型 | 实现方式 | 优点 | 缺点 |
|------|----------|------|------|
| 类适配器 | 继承 Adaptee | 可以重写 Adaptee 方法 | Java 单继承限制，只能适配一个类 |
| 对象适配器 | 组合 Adaptee | 灵活，可适配多个类 | 无法重写 Adaptee 方法 |

> **推荐**：对象适配器（组合优于继承）

---

## 四、版本演进

- `v1_class` - 类适配器：通过继承实现适配
- `v2_object` - 对象适配器：通过组合实现适配（推荐）

---

## 五、类图

### 5.1 类适配器

```
┌─────────────┐      ┌──────────────┐
│   Target    │      │   Adaptee    │
│ (interface) │      │   (class)    │
├─────────────┤      ├──────────────┤
│ +request()  │      │ +specificReq │
└─────────────┘      └──────────────┘
       △                    △
       │                    │
       └────────┬───────────┘
                │ extends
       ┌────────┴────────┐
       │     Adapter     │
       ├─────────────────┤
       │ +request()      │
       │   → specificReq │
       └─────────────────┘
```

### 5.2 对象适配器

```
┌─────────────┐      ┌──────────────┐
│   Target    │      │   Adaptee    │
│ (interface) │      │   (class)    │
├─────────────┤      ├──────────────┤
│ +request()  │      │ +specificReq │
└─────────────┘      └──────────────┘
       △                    ◇
       │ implements         │ has-a
       │                    │
       ├────────────────────┤
       │      Adapter       │
       ├────────────────────┤
       │ -adaptee: Adaptee  │
       │ +request()         │
       │   → adaptee.spec() │
       └────────────────────┘
```

---

## 六、适用场景

1. **系统集成**：需要使用现有的类，但其接口不符合系统需求
2. **第三方 SDK**：集成第三方库，统一为内部接口
3. **遗留系统改造**：老系统接口不变，新系统通过适配器对接
4. **接口统一**：多个不同来源的数据，统一为同一接口处理

---

## 七、JDK & Spring 应用

| 框架 | 类 | 说明 |
|------|-----|------|
| JDK | `InputStreamReader` | 将 `InputStream` 适配为 `Reader` |
| JDK | `OutputStreamWriter` | 将 `OutputStream` 适配为 `Writer` |
| JDK | `Arrays.asList()` | 将数组适配为 `List` |
| Spring MVC | `HandlerAdapter` | 将不同类型的 Handler 统一适配 |
| Spring Security | `UserDetailsService` | 将自定义用户服务适配为 Spring Security 接口 |

---

## 八、与其他模式对比

| 模式 | 目的 | 接口变化 |
|------|------|----------|
| 适配器模式 | 接口转换 | 接口不同 |
| 装饰器模式 | 功能增强 | 接口相同 |
| 代理模式 | 控制访问 | 接口相同 |
| 门面模式 | 简化接口 | 提供新接口 |

---

## 九、面试常见问题

### Q1：类适配器和对象适配器选择？

> **答**：优先选择**对象适配器**，因为：
> 1. 符合"组合优于继承"原则
> 2. 可以适配多个类
> 3. 更加灵活

### Q2：适配器模式和装饰器模式的区别？

> **答**：
> - **适配器**：改变接口，使不兼容的接口协同工作
> - **装饰器**：不改变接口，动态添加新功能

### Q3：Spring MVC 中的 HandlerAdapter 是什么？

> **答**：Spring MVC 支持多种 Controller 类型（`@Controller`、`HttpRequestHandler`、`Controller` 接口等），
> `HandlerAdapter` 将不同类型的 Handler 适配为统一的处理方式。

---

> 📌 **学习建议**：适配器模式较为简单，重点理解"接口转换"的核心思想，以及类适配器和对象适配器的区别。
