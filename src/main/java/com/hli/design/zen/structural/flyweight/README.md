# 享元模式 (Flyweight Pattern)

> 📖 对应《设计模式之禅》第28章：享元模式

---

## 一、概述

**享元模式**（Flyweight Pattern）运用共享技术有效地支持大量细粒度对象的复用，通过共享已存在的对象来减少内存消耗和创建开销。

> **核心思想**：共享对象，减少内存消耗，将对象的状态分为内部状态（可共享）和外部状态（不可共享）

---

## 二、角色定义

| 角色 | 说明 |
|------|------|
| Flyweight（抽象享元） | 定义享元对象的接口，声明操作外部状态的方法 |
| ConcreteFlyweight（具体享元） | 实现抽象享元，存储内部状态（可共享） |
| UnsharedFlyweight（非共享享元） | 不可共享的享元实现，通常作为具体享元的组合 |
| FlyweightFactory（享元工厂） | 创建并管理享元对象，确保共享 |

---

## 三、内部状态 vs 外部状态

| 状态类型 | 说明 | 示例 |
|----------|------|------|
| 内部状态（Intrinsic） | 存储在享元对象内部，不随环境变化，可共享 | 字符编码、字体名称 |
| 外部状态（Extrinsic） | 随环境变化，由客户端传入，不可共享 | 字符位置、字体颜色 |

---

## 四、版本演进

- `common` - 公共组件：享元接口、享元工厂
- `v1_simple` - 简单享元：单纯的对象池实现
- `v2_composite` - 复合享元：享元与组合模式结合

---

## 五、类图

```
┌─────────────────┐
│FlyweightFactory │
├─────────────────┤
│ -pool: Map      │─────────────>┌───────────────┐
│ +getFlyweight() │              │   Flyweight   │
└─────────────────┘              │  (interface)  │
                                 ├───────────────┤
                                 │ +operation(   │
                                 │   extrinsic)  │
                                 └───────────────┘
                                        △
                                        │
                         ┌──────────────┴──────────────┐
                         │                             │
              ┌──────────────────┐          ┌──────────────────┐
              │ConcreteFlyweight │          │UnsharedFlyweight│
              ├──────────────────┤          ├──────────────────┤
              │ -intrinsicState  │          │ +operation(     │
              │ +operation(     │           │   extrinsic)    │
              │   extrinsic)    │           └──────────────────┘
              └──────────────────┘
```

---

## 六、经典案例：围棋游戏

### 问题场景
围棋有大量棋子，每个棋子都有颜色、形状等属性。

### 状态划分
- **内部状态（可共享）**：棋子颜色（黑/白）、形状、大小
- **外部状态（不可共享）**：棋子在棋盘上的位置

### 实现效果
- 不用享元：361 个棋子对象
- 使用享元：只需 2 个棋子对象（黑子、白子）+ 位置信息

---

## 七、适用场景

1. **大量相似对象**：系统中存在大量相似或相同的对象
2. **内存敏感**：对象创建和存储成本较高
3. **可分离状态**：对象的绝大部分状态可以外部化
4. **对象池场景**：需要缓存和复用对象

---

## 八、JDK & Spring 应用

| 框架 | 类 | 说明 |
|------|-----|------|
| JDK | `Integer.valueOf()` | IntegerCache 缓存 -128~127 |
| JDK | `String` 常量池 | 字符串字面量共享 |
| JDK | `Boolean.valueOf()` | TRUE/FALSE 两个对象复用 |
| Apache Commons | `ObjectPool` | 通用对象池 |
| Spring | Bean 单例 | 默认单例作用域实现对象共享 |

---

## 九、与其他模式对比

| 模式 | 目的 | 共享方式 |
|------|------|----------|
| 享元模式 | 减少对象数量 | 共享细粒度对象 |
| 单例模式 | 确保唯一实例 | 全局唯一一个对象 |
| 工厂模式 | 创建对象 | 可配合享元管理对象池 |
| 组合模式 | 表示层次结构 | 复合享元常与组合结合 |

---

## 十、注意事项

1. **线程安全**：享元对象的内部状态必须是不可变的，或者保证线程安全
2. **外部状态管理**：外部状态由客户端维护，增加了使用复杂度
3. **适度使用**：不是所有场景都适合，需要权衡共享带来的收益和复杂度

---

## 十一、面试常见问题

### Q1：什么是享元模式？

> **答**：通过共享技术复用已有对象，减少内存消耗。核心是区分内部状态（可共享）和外部状态（不可共享）。

### Q2：享元模式和单例模式的区别？

> **答**：
> - **单例模式**：一个类只有一个实例
> - **享元模式**：可以有多个实例，但相同内部状态的对象共享

### Q3：Integer 缓存是享元模式吗？

> **答**：是的。`Integer.valueOf(int)` 对 -128~127 范围内的整数进行缓存，相同值返回同一对象实例。

```java
Integer a = Integer.valueOf(100);  // 从缓存获取
Integer b = Integer.valueOf(100);  // 从缓存获取
System.out.println(a == b);       // true
```

---

> 📌 **学习建议**：享元模式在 JDK 中广泛应用（如 String 常量池、Integer 缓存），重点理解"内部状态"和"外部状态"的划分原则。
